# 一个轻量级即时聊天程序设计与实现

## 设计思路

我的设计中，轻量级的服务端实际上只是为多个客户端提供鉴权、发现以及可靠的数据报转发服务，为客户端两两之间创建了可靠的端对端的数据报交换通道。几乎所有功能，包括聊天、“正在输入”的提示、文件传输和共享画板，均由客户端实现，封装到统一的数据包交给服务器进行转发，服务器无需理解包内容。另外，服务器和客户端之间的通信还加入了TLS加密层，确保会话内容的保密性和完整性。

未来，还可以实现NAT穿透，进而为客户端真正创建端对端的直接通信，而无需经过中间服务器的转发。

## 协议

服务器与客户端之间的通信使用TCP，传递的数据以包为单位。一般来说，客户端与服务器的交互是请求—响应式的，同时为了提高聊天的实时性，也支持服务器主动推送消息数据包。

每一个数据包的格式统一如下：

```
 0      3  4   5   ...
+--------+----+----...
|  长度  |类型|数据...
+--------+----+----...
```

其中，`长度`存放`数据`的长度（用于解决黏包问题，见下），`类型`表示`数据`中存放的对象的类型，`数据`存放使用protobuf序列化为字节串的对象，即数据包的实际内容。

根据类型的不同，数据包可分为以下几种：

* `LoginRequest`：客户端登录时发送此请求来登录。
* `LoginResponse`：
* `RegisterRequest`
* `RegisterResponse`
* `ListUserRequest`
* `ListUserResponse`
* `ListBuddyRequest`
* `ListBuddyResponse`
* `AddBuddyRequest`
* `AddBuddyResponse`
* `Message`

具体定义可以参见`chat.proto`。

实际上，对于请求和响应（以结尾的`Request`或`Response`类型）类型的数据包，由于客户端一定发送请求，服务端一定发送响应，所以对于此类数据包，在`类型`中请求和响应可以使用相同的数值来表示。

### 黏包与接收不全问题

由于TCP是可靠的面向**字节流**的传输层协议，它不保证保留消息边界，即多次`send`的数据可能一次`recv`就能够接收，或一次`send`的数据可能需要分多次`recv`接收。这里我采用“字符计数法”，发送时先发长度再发数据，接收的时候先接收长度，再循环接收，直到收到相应长度的数据才停止，就可以确保收到大小正确的应用层数据包了。

## 功能实现

### 即时聊天

### 文件传输

### “正在输入”的提示

当客户端检测到聊天窗口中待发送内容文本框的内容变化（即`TextBox`的`TextChanged`事件被触发）后，会给对方发送“正在输入”消息数据包，从而使得对方显示“正在输入…”字样。

为了减少网络使用，提高效率，“正在输入”的消息数据包至少隔一秒才发一次，同时，为确保显示的连续性，每次收到对方的“正在输入”消息数据包会持续显示“正在输入...”字样一秒。

### 共享画板

## 思考题

**1. Socket与文件的关系**



**2. 服务器程序的角色**

在设计思路中已经说明，服务器程序的核心角色就是包转发器。

**3. 服务器端口与客户端连接个数的关系**



## 总结和收获

这个实验算是本课程的大实验，我在完成这个实验中用到了socket、C++11的多线程及互斥体、protobuf库以及openssl库。

Socket是网络开发一定会使用的，而多线程是并发程序的关键，也是网络程序的关键，通过使用它们来完成本次实验，我对于网络程序的开发及其设计思想的理解更加深刻了。

此外，这一次我还尝试使用了两个外部库，protobuf以及openssl，方便快捷地实现了数据对象的序列化以及TLS加密层的安装，加强了我使用外部网络库的能力。