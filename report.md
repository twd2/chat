# 一个轻量级即时聊天程序设计与实现

## 设计思路

我的设计中，轻量级的服务端实际上只是为多个客户端提供鉴权、发现以及可靠的数据报转发服务，为客户端两两之间创建了可靠的端对端的数据报交换通道。几乎所有功能，包括聊天、“正在输入”的提示、文件传输和共享画板，均由客户端实现，包装成统一的数据包交给服务器进行转发，服务器无感知。

未来，还可以实现NAT穿透，进而为客户端真正创建端对端的直接通信，而无需经过中间服务器的转发。

## 协议

服务器与客户端之间的通信使用TCP，客户端与服务器传递信息以包为单位，

其中，`长度`存放`数据`的长度（用于解决黏包问题，见下），`类型`表示`数据`中存放的对象的类型，`数据`存放使用protobuf序列化为字节串的对象。

```
 0      3  4   5   ...
+--------+----+----...
|  长度  |类型|数据...
+--------+----+----...
```

根据类型的不同，数据包可分为如下几种：

* `LoginRequest`
* `LoginResponse`
* `RegisterRequest`
* `RegisterResponse`
* `ListUserRequest`
* `ListUserResponse`
* `ListBuddyRequest`
* `ListBuddyResponse`
* `AddBuddyRequest`
* `AddBuddyResponse`
* `Message`

具体定义可以参见`chat.proto`。

实际上，对于请求和响应（以结尾的`Request`或`Response`类型）类型的数据包，由于客户端一定发送请求，服务端一定发送响应，所以在`类型`中可以使用相同的数值来表示。

### 黏包与接收不全问题

由于TCP是可靠的面向字节流的传输层协议，它不保证保留消息边界，即多次`send`的数据可能一次`recv`就能够接收，或一次`send`的数据可能需要分多次`recv`接收。这里我采用“字符计数法”，发送时先发长度再发数据，接收的时候先接收长度，再循环接收，直到收到相应长度的数据才停止，就可以确保收到大小正确的应用层数据包了。

## 功能实现

### 即时聊天

### “正在输入”的提示

### 文件传输

### 共享画板

## 思考题

**1. Socket与文件的关系**



**2. 服务器程序的角色**



**3. 服务器端口与客户端连接个数的关系**



## 总结和收获

这个实验算是本课程的大实验，我在完成这个实验中用到了socket、多线程、protobuf库以及openssl库。